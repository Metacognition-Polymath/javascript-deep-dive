# 12. 함수

- 수학의 함수 : `입력`을 받아 `출력`을 내보내는 일련의 과정

## 12.1 함수란?

- 함수 : 일련의 과정을 문(statement)으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것
  - 입력을 받아서 출력을 내보냄

## 12.2 함수를 사용하는 이유

- 함수는 필요할 때 여러번 호출할 수 있다
- 실행 시점을 개발자가 결정할 수 있고 몇번이든 `코드의 재사용`이 가능하다
- 함수의 적절한 이름 -> 코드의 가독성 향상

## 12.3 함수 리터럴

```js
// 예제 12-4. 변수에 함수 리터럴을 할당
var f = function add(x, y) {
  return x + y;
};
```

- 함수 리터럴도 평가되어 값을 생성하며, 이 값은 객체다
  - 즉, 함수는 객체다

#### 함수의 리터럴의 구성요소

- 함수 이름
- 매개변수 목록
- 함수 몸체

- 함수 객체 vs 일반 객체
  - 일반 객체는 호출할 수 없지만 함수는 호출할 수 있다
  - 일반 객체에는 없는 함수 객체만의 고유한 프로퍼티를 갖는다
  - 18장 - 함수와 일급 객체에서 자세히 다룸

## 12.4 함수 정의

- 함수 정의 vs 변수 선언
  - 함수 선언문이 평가되면 식별자가 암묵적으로 생성되고 함수 객체가 할당된다

### 함수 선언문

```js
function add(x, y) {
  return x + y;
}
```

- 함수 리터럴과 형태가 동일, 함수 이름을 생략할 수 없다
- 표현식이 아닌 문이다.
- 선언문의 이름은 자바스크립트 엔진이 암묵적으로 식별자로 생성한다.

### 함수 표현식

```js
const func1 = function add(x: number, y: number) {
  return x + y;
};

// console.log("add", add(1, 2)); // TS2304: Cannot find name 'add'.
console.log("func1", func1(1, 2));
```

- function의 이름(add)를 붙이면 기명 함수 표현식
  - 생략하는 것이 일반적임

### 함수 생성 시점과 함수 호이스팅

- 호이스팅 : 코드의 선두로 끌어 올려지는 것 => 함수 호이스팅, 변수 호이스팅
  - 함수 선언문(함수 리터럴) : 호이스팅이 될 때 함수 내용도 같이 됨
    - 함수 호이스팅
  - 함수 표현식 : 호이스팅이 될 때 변수는 undefined로 초기화 되고, 변수에 함수가 할당되는 것은 할당되는 위치에서 할당 됨
    - 변수 호이스팅

### Function 생성자 함수

- new를 붙여서 실행한 생성자 함수는 클로저를 생성하지 않는 등 일반적인 함수와 다르게 동작한다.

### 화살표 함수

```js
const add = (x, y) => x + y;
console.log(add(2, 5)); // 7
```

- this바인당 방식이 다름
- prototype 프로퍼티가 없음
- **arguments 객체를 생성하지 않음**

![arrowFunction_vs_function](./dir_function.png)

- 26.3절에서 자세히 다룸

## 12.5 함수 호출

### 12.5.1 매개변수와 인수

### 12.5.2 인수 확인

- ES6 부턴 js에서도 함수 매개변수의 기본값을 지정할 수 있다.

```js
// ES6에서 매개변수의 기본값이 도입 됨
function add(x = 0, y = 1) {
  return x + y;
}

console.log(add());
```

### 12.5.3 매개변수의 최대 개수

### 12.5.4 반환문

## 12.6 참조에 의한 전달과 외부 상태의 변경

## 12.7 다양한 함수의 형태

- 즉시 실행 함수
- 재귀 함수
- 중첩 함수
- 콜백 함수
- 순수 함수와 비순수 함수
